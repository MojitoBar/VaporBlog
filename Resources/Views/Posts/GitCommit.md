---
date: 2022년 07월 23일 20:37
description: Git의 내부 동작 방식
oneline: Git이 내부적으로 어떻게 작동하는가. 근데 이제 Commit을 곁들인
tags: Git
thumbnail: /images/git.png
contents: 서론/Git 이란?/버전 관리 시스템/깃의 내부 동작 원리/Git 명령어들 도식화/Commit의 옵션들
file: Protocol
---

## 서론

어쩌다 저쩌다 기회가 되서 버전 관리 시스템인 ~~Git~~이 내부적으로 어떻게 동작하는지를 필두로 간단한 Commit의 옵션들을 정리해봤습니다.

## Git 이란?
    
~~Git~~이 내부적으로 어떻게 동작하기에 앞서 Git이 무엇인지 알아보고 넘어가려 합니다.

Git은 오픈소스의 아버지라고 불리는 **리누스 토발즈**가 직접 창시한 버전 관리 도구입니다.

> 깃(Git)은 컴퓨터 파일의 변경사항을 추적하고 여러 명의 사용자들 간에 해당 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템이다. 또는 이러한 명령어를 가리킨다. [출처](https://ko.wikipedia.org/wiki/%EA%B9%83_(%EC%86%8C%ED%94%84%ED%8A%B8%EC%9B%A8%EC%96%B4)) 

위키백과에 명시되어있는 깃의 정의인데요, 핵심은 ~~버전 관리 시스템~~이라 보면 될 것 같습니다.

그래서 우리는 보통 소프트웨어를 개발할 때 파일들의 작업을 조율하기 위한 분산 버전 관리 시스템으로 깃을 사용합니다.

## 버전 관리 시스템

**Git**이 버전 관리 시스템으로 매우 잘 알려져있지만 이전에는 **SVN***이라는 버전 관리 도구를 사용하곤 했습니다. (현재도 채택하고 있는 곳이 있다고 합니다.)

Git과 SVN은 모두 오픈소스이며 버전 관리 도구이지만 몇 가지 차이점이 있습니다.

가장 대표적인 차이점이라면 ~~중앙 집중식~~(SVN)과 ~~분산 관리식~~(Git)이라는 점인데요, 아래 사진을 보면 더욱 쉽게 이해할 수 있습니다.

<img alt="gitsvn" src="/images/gitsvn.png"/>
    
그림에도 알 수 있듯이 Git의 경우엔 **각각의 로컬 레파지토리에서 버전이 관리**된다면, SVN의 경우엔 **중앙 리모트 레파지토리에서 하나의 버전이 관리**된다는 것입니다.

때문에 SVN이 직관적인 장점이 있지만 충돌이 일어날 확률이 높고, Git의 경우 비교적 직관적이지 못하지만 충돌이 일어날 확률이 적습니다.

더 다양한 차이점은 아래 사진을 참고해주세요.

<img alt="gitvssvn" src="/images/gitvssvn.png"/>

## 깃의 내부 동작 원리

보통 대부분의 사람들이 **add, commit, push**를 반복하며 내부적으로 어떻게 동작하는지는 관심이 없을텐데요, 이번을 기회로 한번 확인해본다면 git의 여러 명령어들이 더욱 친숙하게 다가올 수 있을 것 같습니다.

자세한 정보를 위해 git의 내부를 잘 나타낸 사진을 먼저 보겠습니다. [출처](https://it-eldorado.tistory.com/4)

<img alt="insidegit" src="/images/insidegit.png"/>
    
그림에 있는 **키워드**들을 잠깐 살펴보자면,

### ~~Index~~

개념적으로는 커밋이 이뤄질 준비가 된 파일의 내용들이 위치하는 영역을 의미하며, 실제로는 하나의 파일로서 존재합니다.

### ~~Repository(.git/objects/)~~

깃이 버전 관리를 하기 위해 필요로 하는 데이터들을 저장하는 곳입니다. 버전 관리를 시작한 시점부터 현재 시점까지 관리해온 여러 버전들에 해당하는 파일들의 내용이 Blob 파일로서 저장되어 있습니다.

### ~~Blob 파일~~

버전 관리하는 파일들 각각의 깃의 저장소에서 Blob 파일의 형태로 저장됩니다. 

파일의 내용에 SHA1이라는 해싱 기법을 적용하여 Blob 파일의 이름을 얻어내기 때문에, **내용이 같은 파일들은 모두 하나의 Blob 파일로서 저장됩니다.** 

이러한 원리로 깃은 여러 버전에 걸쳐 존재하는 파일들의 내용을 중복 없이 관리할 수 있게 됩니다.

### ~~HEAD~~

현재 접속한 브랜치를 포인터로써 가르킵니다.

### ~~.git/refs/heads~~

해당 브랜치에 가장 최신 정보 (commit hash)를 가집니다.

### ~~Commit 파일~~

하나의 버전을 생성한다는 것은 하나의 Commit 파일을 만드는 것을 의미합니다. 

Commit 파일은 하나의 Tree 파일을 가리키게 되어 있습니다. 

이 파일에는 **가리키고 있는 Tree 파일의 주소와 직전 버전에 해당하는 Commit 파일의 주소가 기록**됩니다.

### ~~Tree 파일~~

커밋 시점의 파일들 각각에 대해 그 파일명과 해당 파일의 내용을 담고 있는 Blob 파일의 주소가 기록됩니다. 

즉, add를 하게되면 로컬의 변경사항을 인덱스에 반영하게 되고, commit을 하게되면 index에 저장된 변경사항을 하나의 버전으로 저장하게 되는 것입니다.

## Git 명령어들 도식화

<img alt="gitcommand" src="/images/gitcommand.png"/>

위에서 알아본 각각의 폴더와 파일이 명령어와 어떤 관계가 있는지 나타낸 사진입니다.

## Commit의 옵션들

공식문서를 보면 Commit만 해도 정말 많은 옵션들이 있는데요 그 중 자주쓰는 옵션이나 기본적인 것들에 대해 정리해봤습니다.

### ~~-a / —all~~

수정 및 삭제된 파일을 자동으로 준비하도록 명령에 지시하지만 Git에 알리지 않은 새 파일은 영향을 받지 않습니다. 

해당 옵션을 사용하면 사진과 같은 vim 창이 뜨고 아래 커밋 메시지와 함께 저장하면 커밋이 완료됩니다.
        

<img alt="gitvim" src="/images/gitvim.png"/>

### ~~-p / -patch~~

 대화형 패치 선택 인터페이스를 사용하여 커밋할 변경 사항을 선택합니다. 자세한 내용은 [git-add](https://git-scm.com/docs/git-add)를 참조하세요.

### ~~-C commit / —reuse-message=commit ~~

 기존 커밋 객체를 가져와 커밋 생성 시 로그 메시지와 저자 정보(타임스탬프 포함)를 재사용합니다. 

commit 에는 아래 사진에 보이는 ~~2f70cec~~ 와 같은 commit 객체를 붙여넣으면 됩니다.

<img alt="commitc" src="/images/commitc.png"/>

### ~~-c commit / —reedit-message=commit~~

C와 유사하지만 -c를 사용하면 편집기가 호출되므로 사용자가 커밋 메시지를 추가로 편집할 수 있습니다.

### ~~—fixup=[(amend|reword):]commit~~

rebase를 위한 목적지 커밋을 지정할 때 사용합니다. [자세한 설명 링크](https://enghqii.tistory.com/54) amend와 reword는 선택 사항이고 commit은 마찬가지로 commit 객체를 사용하면 됩니다. 

이렇게 커밋하면 아래 사진과 같이 앞에 “fixup!”이라고 메시지가 추가됩니다.

<img alt="fixup" src="/images/fixup.png"/>

### ~~—squash=commit~~

rebase --autosquash와 함께 사용할 커밋 메시지를 구성합니다. 커밋 메시지 제목 줄은 ~~squash!~~ 접두사가 있는 지정된 커밋에서 가져옵니다. 

추가 커밋 메시지 옵션(-m/-c/-C/-F)과 함께 사용할 수 있습니다. 자세한 내용은 [git-rebase](https://git-scm.com/docs/git-rebase)를 참조하세요. 

해당 명령어를 단독으로 사용하지는 않는 것 같고 rebase를 할 때 필요한 명령어로 보입니다. [자세한 설명 링크](https://meetup.toast.com/posts/39)

### ~~m msg / —message=msg~~

주어진 msg를 커밋 메시지로 사용합니다. 여러 -m 옵션이 제공되면 해당 값은 별도의 단락으로 연결됩니다. 메시지와 함께 커밋할때 사용하며, **-c**, **-C**, **-F**와 함께 사용할 수 없습니다.

### ~~-F file / —file=file~~

주어진 파일에서 커밋 메시지를 가져옵니다. -를 사용하여 표준 입력에서 메시지를 읽습니다. 실행 해보니 파일 내용을 그대로 가져오는 듯합니다. 예를 들어 **git commit -F README.md** 로 커밋을 남기면 파일 내용이 그대로 커밋 메시지에 남습니다.

## 참고자료
<ul>
<li>
    <a href="https://steady-coding.tistory.com/277">git commit 이란?</a>
</li>
<li>
    <a href="https://it-eldorado.tistory.com/4">깃 내부 동작 원리에 대한 이해</a>
</li>
<li>
    <a href="https://dzzienki.tistory.com/46">Git vs SVN</a>
</li>
</ul>
